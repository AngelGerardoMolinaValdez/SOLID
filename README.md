# IntroducciÃ³n a los Principios SOLID ğŸš€

Bienvenido al repositorio dedicado a practicar y entender los fundamentos de los principios SOLID, una metodologÃ­a clave para el desarrollo de software orientado a objetos. AquÃ­, exploraremos cada uno de los principios con ejemplos prÃ¡cticos en diferentes lenguajes de programaciÃ³n, permitiÃ©ndote ver su aplicaciÃ³n en mÃºltiples escenarios.

## Objetivos del Repositorio ğŸ¯

Este repositorio tiene como objetivo proporcionar una plataforma para practicar e implementar los principios SOLID en diferentes escenarios y con diversos lenguajes de programaciÃ³n, incluyendo pero no limitÃ¡ndose a Java, C#, Python, y JavaScript.

Cada principio se explorarÃ¡ a travÃ©s de ejemplos prÃ¡cticos y ejercicios que podrÃ¡s realizar para fortalecer tu comprensiÃ³n y habilidad en la aplicaciÃ³n de estos principios fundamentales en el desarrollo de software.

## Â¿QuÃ© son los Principios SOLID? ğŸ§

Los principios SOLID son un conjunto de cinco reglas diseÃ±adas para mejorar la legibilidad, escalabilidad y mantenibilidad del software. Fueron introducidos por Robert C. Martin en su trabajo a principios de los 2000s, aunque el acrÃ³nimo SOLID fue popularizado por Michael Feathers. Estos principios ayudan a los desarrolladores a crear sistemas de software mÃ¡s robustos, flexibles y mantenibles.

## Los Principios ğŸ› 

### 1. Principio de Responsabilidad Ãšnica (Single Responsibility Principle - SRP) âœ”ï¸

**DefiniciÃ³n:** Una clase debe tener una y solo una razÃ³n para cambiar, lo que significa que una clase debe tener solo una tarea o responsabilidad.

### 2. Principio de Abierto/Cerrado (Open/Closed Principle - OCP) ğŸšª

**DefiniciÃ³n:** Las entidades de software (clases, mÃ³dulos, funciones, etc.) deben estar abiertas para su extensiÃ³n, pero cerradas para su modificaciÃ³n.

### 3. Principio de SustituciÃ³n de Liskov (Liskov Substitution Principle - LSP) ğŸ‘©â€ğŸ’¼

**DefiniciÃ³n:** Los objetos de una superclase deben ser sustituibles por objetos de sus subclases sin afectar la correctitud del programa.

### 4. Principio de SegregaciÃ³n de Interfaz (Interface Segregation Principle - ISP) ğŸ½

**DefiniciÃ³n:** NingÃºn cliente debe ser forzado a depender de mÃ©todos que no utiliza.

### 5. Principio de InversiÃ³n de Dependencias (Dependency Inversion Principle - DIP) ğŸ”„

**DefiniciÃ³n:** Los mÃ³dulos de alto nivel no deben depender de mÃ³dulos de bajo nivel. Ambos deben depender de abstracciones. AdemÃ¡s, las abstracciones no deben depender de los detalles; los detalles deben depender de las abstracciones.
